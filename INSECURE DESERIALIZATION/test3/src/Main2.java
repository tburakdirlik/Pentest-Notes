/*You should see the string vickie printed as the output. Let’s break down the program a bit.
First, we define a class named User that implements Serializable 1. Only classes that implement
Serializable can be serialized and deserialized. The User class has a username attribute that
is used to store the user’s username 2. Then, we create a new User object 3 and set its username
to the string "vickie" 4. We write the serialized version of newUser and  store it into the
file object.ser 5. Finally, we read the object from the file, deserialize it, and print out the
user’s username 6. To exploit Java applications via an insecure deserialization bug, we first have
to find an entry point through which to insert the malicious serialized object. In Java
applications, serializable objects are often used to transport data in HTTP headers, parameters,
or cookies. Java serialized objects are not human readable like PHP serialized strings. They often
contain non-printable characters as well. But they do have a couple signatures that can help you
recognize them and find potential entry points for your exploits:
    • Starts with AC ED 00 05 in hex or rO0 in base64. (You might see these
      within HTTP requests as cookies or parameters.)
    • The Content-Type header of an HTTP message is set to application/x
-java-serialized-object.
Since Java serialized objects contain a lot of special characters, it’s common to encode them before
transmission, so look out for differently encoded versions of these signatures as well. After you
discover a user-supplied serialized object, the first thing you can try is to manipulate program
logic by tampering with the information stored within the objects. For example, if the Java object
is used as a cookie for access control, you can try changing the usernames, role names, and
other identity markers that are present in the object, re-serialize it, and relay it back to the
application. You can also try tampering with any sort of value in the object that is a filepath,
file specifier, or control flow value to see if you can alter the program’s flow.
Sometimes when the code doesn’t restrict which classes the application is allowed to deserialize,
it can deserialize any serializable classes to which it has access. This means attackers can create
their own objects of any class. A potential attacker can achieve RCE by constructing objects of the
right classes that can lead to arbitrary commands.
* */